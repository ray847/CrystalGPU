#ifndef CRYSTALGPU_IMPL_GLAN_CODE_GEN_PROCEDURE_H_
#define CRYSTALGPU_IMPL_GLAN_CODE_GEN_PROCEDURE_H_

#include <stdint.h>
#include <vector>
#include <string>
#include <string_view>
#include <unordered_set>

#include "function.h"
#include "tuple.h"

namespace crystal::gpu::impl::glan::code_gen {

using std::vector, std::string, std::unordered_set, std::string_view;

class PROCEDURE {
 public:
  void PUSH(const string& STR) {
    CURR_FUNCTION_->BLOCK().PUSH(STR);
  }
  void PUSH(string&& STR) {
    CURR_FUNCTION_->BLOCK().PUSH(STR);
  }
  template <typename LAMBDA>
  void PUSH(LAMBDA OP) {
    CURR_FUNCTION_->BLOCK().PUSH(OP);
  }
  void PUSH() {
    CURR_FUNCTION_->BLOCK().PUSH();
  }
  /**
   * Begin a function definition.
   *
   * @return A key to the function in the form of a `size_t`.
   */
  size_t BEGIN_FUNCTION(TYPE T) {
    FUNCTIONS_.push_back({T});
    CURR_FUNCTION_ = &FUNCTIONS_.back();
    return FUNCTIONS_.size() - 1;
  }
  const FUNCTION& GET_FUNCTION(size_t IDX) const {
    return FUNCTIONS_[IDX];
  }
  void ADD_PARAM(ATOMIC PARAM) {
    if (CURR_FUNCTION_ == &MAIN_) return;
    CURR_FUNCTION_->SIGNATURE().PARAMS_.push_back(PARAM);
  }
  /**
   * Exit from current scope.
   *
   * If currently in a function and the current scope is already at the most
   * outer scope, the current function switches back to the main function.
   */
  void POP() {
    if (CURR_FUNCTION_ != &MAIN_ && CURR_FUNCTION_->BLOCK().DEPTH() == 0)
        [[unlikely]] {
      CURR_FUNCTION_ = &MAIN_;
    } else if (CURR_FUNCTION_ == &MAIN_ && CURR_FUNCTION_->BLOCK().DEPTH() == 0)
        [[unlikely]] {
      return;
    } else {
      CURR_FUNCTION_->BLOCK().POP();
    }
  }
  void DEFINE_TUPLE(size_t TAG) {
    TUPLE_TAGS_.insert(TAG);
  }
  operator string() const {
    string CODE;
    /* Code Documentations. */
    CODE += GEN_DOC;
    /* Struct Definitions */
    for (auto& TUPLE_TAG : TUPLE_TAGS_)
      CODE += TUPLE::DEFINITION_STATEMENT(TUPLE_TAG);
    /* Functions */
    CODE += MAIN_.DEFINITION();
    for (auto & FUNCTION : FUNCTIONS_) CODE += FUNCTION.DEFINITION();
    return CODE;
  }

 private:
  static constexpr string_view GEN_DOC = R"(
/******************************************************************************
 This shader code is automatically generated by the CrystalGPU library with
 `glan` DSL.
 ******************************************************************************/
)";
  FUNCTION MAIN_{ [] {
    SIGNATURE SIG{};
    SIG.NAME_ = "MAIN";
    SIG.TYPE_ = {"void"};
    return SIG;
  }() };
  vector<FUNCTION> FUNCTIONS_;
  FUNCTION* CURR_FUNCTION_ = &MAIN_;
  unordered_set<size_t> TUPLE_TAGS_;
};

} // namespace crystal::gpu::impl::glan::code_gen

#endif